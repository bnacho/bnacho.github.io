# 넘파이의 인덱싱과 슬라이싱
- 넘파이 배열도 인덱싱과 슬라이싱이 가능하다.


```python
import numpy as np
```

# 1차원 배열
- 1차원 배열은 리스트와 거의 동일하다.

## 1차원 배열의 인덱싱
- 리스트에서 인덱싱 하는 방법과 동일하다.


```python
arr = np.arange(10)
print(arr)
print(arr[0])
print(arr[1])
print(arr[-1])
```

    [0 1 2 3 4 5 6 7 8 9]
    0
    1
    9
    

## 1차원 배열의 슬라이싱
- 기본적으로는 리스트와 같으나 다른 점이 있다.
- 넘파이 배열의 슬라이싱은 새로운 객체를 만드는 것이 아니다.
- 새로운 객체를 만들려면 .copy()를 사용해야 한다.


```python
arr = np.arange(10)
print(arr)
print(arr[5:8])
```

    [0 1 2 3 4 5 6 7 8 9]
    [5 6 7]
    


```python
arr = np.arange(10)
print(arr)

# 슬라이싱 한 것을 다른 변수에 저장
arr_slicing = arr[5:8]
print(arr_slicing)

# 슬라이싱 결과가 저장된 변수에 첫 번째 원소를 변경
arr_slicing[0] = 1000
# 하지만 원래 변수에 영향이 간다.
print(arr)

# 즉 넘파이 배열의 슬라이싱은 새로운 객체를 만드는 것이 아닌
# 원래 배열에 대한 view이다.
```

    [0 1 2 3 4 5 6 7 8 9]
    [5 6 7]
    [   0    1    2    3    4 1000    6    7    8    9]
    


```python
# 새로운 객체 만드는 방법
arr = np.arange(10)
print(arr)

# 슬라이싱 한 것을 다른 변수에 카피한다.
arr_slicing = arr[5:8].copy()
print(arr_slicing)

# 슬라이싱 결과가 저장된 변수에 첫 번째 원소를 변경
arr_slicing[0] = 1000
# 이번에는 원래 배열에 영향이 가지 않는다.
print(arr)
```

    [0 1 2 3 4 5 6 7 8 9]
    [5 6 7]
    [0 1 2 3 4 5 6 7 8 9]
    

# 2차원 배열
- 2차원 배열의 원소는 스칼라가 아닌 1차원 벡터이다.
- 각각의 1차원 벡터의 원소에 접근하려면 대괄호를 두 번 써야한다.
- 쉼표를 사용해도 1차원 벡터의 원소에 접근할 수 있다.

## 2차원 배열의 인덱싱


```python
# 2차원 배열의 인덱싱
arr2d = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
print(arr2d[0])
print(arr2d[0][0])
print(arr2d[0,0])
```

    [1 2 3]
    1
    1
    

## 2차원 배열의 슬라이싱


```python
# 2차원 배열의 슬라이싱
arr2d = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
print(arr2d[:2])
print(arr2d[:2, :1])
```

    [[1 2 3]
     [4 5 6]]
    [[1]
     [4]]
    

# 다차원 배열
- 각각의 원소가 무엇이 되는지 잘 살펴봐야 한다.
- 3차원 배열의 경우 원소가 2차원 배열이 된다.


```python
arr3d = np.array([[[1, 2, 3], [4, 5, 6]], [[7, 8, 9], [10, 11, 12]]])
print(arr3d[0])
print(arr3d[0,0])
print(arr3d[0,0,0])
print(arr3d[:2, :1, :1])
```

    [[1 2 3]
     [4 5 6]]
    [1 2 3]
    1
    [[[1]]
    
     [[7]]]
    
